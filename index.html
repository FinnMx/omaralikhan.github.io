<html>
 <meta charset="UTF-8"> 
    <head>
        <title>Tracy Demo</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100% }
        </style>
    </head>
    <body>
        <script src="js/three.min.js"></script>
        <script src="js/cannon.min.js"></script>
        <script src="build/cannon.js"></script>
        <script src="build/cannon.demo.js"></script>
        <script src="libs/dat.gui.js"></script>
        <script src="libs/Three.js"></script>
        <script src="libs/TrackballControls.js"></script>
        <script src="libs/Detector.js"></script>
        <script src="libs/Stats.js"></script>
        <script src="libs/smoothie.js"></script>
        <script>
        var demo = new CANNON.Demo();
        var world = demo.getWorld();
        var vehicles = [];

        function Tracy(x,y,z)
        {
            var chassisShape = new CANNON.Box(new CANNON.Vec3(2.5, 2.5,0.5));
            var chassisBody = new CANNON.Body({ mass: 150 });
            chassisBody.addShape(chassisShape);
            chassisBody.position.set(x,y,z);
            chassisBody.angularVelocity.set(0, 0, 0.7);
            demo.addVisual(chassisBody);

            // Settings for the vehicle.
            var options = {
                radius: 1.4,
                directionLocal: new CANNON.Vec3(0, 0, -1),
                suspensionStiffness: 30,
                suspensionRestLength: 0.3,
                frictionSlip: 1,
                dampingRelaxation: 2.3,
                dampingCompression: 4.4,
                maxSuspensionForce: 100000,
                rollInfluence:  0.01,
                axleLocal: new CANNON.Vec3(0, 1, 0),
                chassisConnectionPointLocal: new CANNON.Vec3(1, 1, 0),
                maxSuspensionTravel: 0.3,
                customSlidingRotationalSpeed: -30,
                useCustomSlidingRotationalSpeed: true
            };

            // Create the vehicle
            var vehicle = new CANNON.RaycastVehicle({
                chassisBody: chassisBody,
            });

            options.chassisConnectionPointLocal.set(1.5, 2.5, 0);
            vehicle.addWheel(options);

            options.chassisConnectionPointLocal.set(1.5, -2.5, 0);
            vehicle.addWheel(options);

            options.chassisConnectionPointLocal.set(-1.5, 2.5, 0);
            vehicle.addWheel(options);

            options.chassisConnectionPointLocal.set(-1.5, -2.5, 0);
            vehicle.addWheel(options);

            vehicle.addToWorld(world);

            // Create wheel shapes.
            vehicle.wheelBodies = [];
            for(var i=0; i<vehicle.wheelInfos.length; i++){
                var wheel = vehicle.wheelInfos[i];
                var cylinderShape = new CANNON.Cylinder(wheel.radius, wheel.radius, wheel.radius / 2, 20);
                var wheelBody = new CANNON.Body({
                    mass: 0
                });
                wheelBody.type = CANNON.Body.KINEMATIC;
                wheelBody.collisionFilterGroup = 0; // turn off collisions
                var q = new CANNON.Quaternion();
                q.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
                wheelBody.addShape(cylinderShape, new CANNON.Vec3(), q);
                vehicle.wheelBodies.push(wheelBody);
                demo.addVisual(wheelBody);
                world.addBody(wheelBody);
            }

            vehicles.push(vehicle);
        }

        demo.addScene("car",function(){
            // Initialise world settings.
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.gravity.set(0, 0, -10);
            world.defaultContactMaterial.friction = 0.1;

            // Create materials.
            var groundMaterial = new CANNON.Material("groundMaterial");
            var wheelMaterial = new CANNON.Material("wheelMaterial");

            // Define ground to wheel material contact constraints.
            var wheelGroundContactMaterial = window.wheelGroundContactMaterial = new CANNON.ContactMaterial(wheelMaterial, groundMaterial, {
                friction: 0.3,
                restitution: 0,
                contactEquationStiffness: 1000
            });

            // Define ground to ground material contact constraints.
            var ground_ground_cm = new CANNON.ContactMaterial(groundMaterial, groundMaterial, {
                friction: 0.4,
                restitution: 0.3,
                contactEquationStiffness: 1e8,
                contactEquationRelaxation: 3,
                frictionEquationStiffness: 1e8,
                frictionEquationRegularizationTime: 3,
            });

            // We must add the contact materials to the world
            world.addContactMaterial(ground_ground_cm);
            world.addContactMaterial(wheelGroundContactMaterial);

            // Create four tracies and set their x,y,z positions.
            Tracy(-60,1,2);


            // Update wheels
            world.addEventListener('postStep', function(){
                for (var j = 0; j < vehicles.length; j++ ) {
                    for (var i = 0; i < vehicles[j].wheelInfos.length; i++) {
                        vehicles[j].updateWheelTransform(i);
                        var t = vehicles[j].wheelInfos[i].worldTransform;
                        var wheelBody = vehicles[j].wheelBodies[i];
                        wheelBody.position.copy(t.position);
                        wheelBody.quaternion.copy(t.quaternion);
                    }
                }
            });

            createFloor()

            // Create a ramp represented as a polyhedron.
            var polyhedronShape = createTetra();
            var polyhedronBody = new CANNON.Body({ mass: 1000, material: groundMaterial });
            polyhedronBody.addShape(polyhedronShape);
            polyhedronBody.position.set(20,-5,1);
            polyhedronBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0,0,1),THREE.Math.degToRad(135));
            world.addBody(polyhedronBody);
            demo.addVisual(polyhedronBody);


            var polyhedronShape = new CANNON.Box(new CANNON.Vec3(5,5,5));
            var polyhedronBody = new CANNON.Body({ mass: 1000, material: groundMaterial });
            polyhedronBody.addShape(polyhedronShape);
            polyhedronBody.position.set(-60,-10,10);
            polyhedronBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0,0,1),THREE.Math.degToRad(135));
            world.addBody(polyhedronBody);
            demo.addVisual(polyhedronBody);

        });

        demo.start();
        var maxSteerVal = 0.5;
        var maxForce = 500;
        var brakeForce = 1000000;
        var rotationForce = 8*maxForce;

        /**
         * Renders the ground as a height field.
         */
        function createFloor()
        {
            // Create a 64 x 16 matrix to store our height field.
            var matrix = [];
            var sizeX = 64,
                sizeY = 16;

            for (var i = 0; i < sizeX; i++) {
                matrix.push([]);
                for (var j = 0; j < sizeY; j++) {
                    height = 1;
                    matrix[i].push(height);
                }
            }

            var hfShape = new CANNON.Heightfield(matrix, {
                elementSize: 200 / sizeX
            });
            // Set mass to 0 so it is a static body and unaffected by gravity.
            var hfBody = new CANNON.Body({ mass: 0 });
            hfBody.addShape(hfShape);
            hfBody.position.set(-sizeX * hfShape.elementSize / 2, -sizeY * hfShape.elementSize / 2, -1);
            world.addBody(hfBody);
            demo.addVisual(hfBody);
        }


        function createTetra()
        {
            var verts = [new CANNON.Vec3(0,0,0),
                         new CANNON.Vec3(40,0,0),
                         new CANNON.Vec3(0,40,0),
                         new CANNON.Vec3(0,0,10)];
            var offset = -0.35;

            for(var i=0; i<verts.length; i++)
            {
                var v = verts[i];
                v.x += offset;
                v.y += offset;
                v.z += offset;
            }
            return new CANNON.ConvexPolyhedron(verts,[[0,3,2],[0,1,3],[0,2,1],[1,2,3]]);
        }

        // Keyboard Controls
        document.onkeydown = handler;
        document.onkeyup = handler;

        // Extra boost multiplier to make the car move slower or faster.
        var boost = 0.5;

        function handler(event){
            var up = (event.type == 'keyup');

            if(!up && event.type !== 'keydown'){
                return;
            }

            // Set breaks to reset car to initial position.
            vehicles[0].setBrake(0, 0);
            vehicles[0].setBrake(0, 1);
            vehicles[0].setBrake(0, 2);
            vehicles[0].setBrake(0, 3);

            switch(event.keyCode){
            case 38: // forward
                vehicles[0].applyEngineForce(up ? 0 : -maxForce*boost, 2);
                vehicles[0].applyEngineForce(up ? 0 : -maxForce*boost, 3);
                break;

            case 40: // backward
                vehicles[0].applyEngineForce(up ? 0 : maxForce*boost, 2);
                vehicles[0].applyEngineForce(up ? 0 : maxForce*boost, 3);
                break;

            case 66: // b
                vehicles[0].setBrake(brakeForce, 0);
                vehicles[0].setBrake(brakeForce, 1);
                vehicles[0].setBrake(brakeForce, 2);
                vehicles[0].setBrake(brakeForce, 3);
                break;

            case 70: // f
                  useSensors();
                  break;

            case 39: // right
                vehicles[0].applyEngineForce(up ? 0 : rotationForce, 1);
                vehicles[0].applyEngineForce(up ? 0 : rotationForce, 3);
                vehicles[0].applyEngineForce(up ? 0 : -rotationForce, 0);
                vehicles[0].applyEngineForce(up ? 0 : -rotationForce, 2);
                break;

            case 37: // left
                vehicles[0].applyEngineForce(up ? 0 : -rotationForce, 1);
                vehicles[0].applyEngineForce(up ? 0 : -rotationForce, 3);
                vehicles[0].applyEngineForce(up ? 0 : rotationForce, 0);
                vehicles[0].applyEngineForce(up ? 0 : rotationForce, 2);
                break;

            }
        }

        var stats = 
        {
            AccelerationX: 0,
            AccelerationY: 0,
            AccelerationZ: 0,
            OrientationX:0,
            OrientationY:0,
            OrientationZ:0,
            AngularVelocityX: 0,
            AngularVelocityY: 0,
            AngularVelocityZ: 0
        }

        gui = new dat.GUI();
        gui.addFolder("Accelerometer");
        gui.add(stats,"AccelerationX",-10,10).listen();
        gui.add(stats,"AccelerationY",-10,10).listen();
        gui.add(stats,"AccelerationZ",-10,10).listen();

        gui.addFolder("Magnetometer");
        gui.add(stats,"OrientationX",-1,1).listen();
        gui.add(stats,"OrientationY",-1,1).listen();
        gui.add(stats,"OrientationZ",-1,1).listen();

        gui.addFolder("Gyroscope");
        gui.add(stats,"AngularVelocityX",-10,10).listen();
        gui.add(stats,"AngularVelocityY",-10,10).listen();
        gui.add(stats,"AngularVelocityZ",-10,10).listen();

        var oldVelocity = new CANNON.Vec3(0,0,0);
        function updateStats()
        {
            newVelocity = new CANNON.Vec3(0,0,0);
            newVelocity.copy(vehicles[0].chassisBody.velocity);
            var acceleration = oldVelocity.vsub(newVelocity);

            stats.AccelerationX = acceleration.x;
            stats.AccelerationY = acceleration.y;
            stats.AccelerationZ = acceleration.z;

            stats.OrientationX = vehicles[0].chassisBody.quaternion.x;
            stats.OrientationY = vehicles[0].chassisBody.quaternion.y;
            stats.OrientationZ = vehicles[0].chassisBody.quaternion.z;

            stats.AngularVelocityX = vehicles[0].chassisBody.angularVelocity.x;
            stats.AngularVelocityY = vehicles[0].chassisBody.angularVelocity.y;
            stats.AngularVelocityZ = vehicles[0].chassisBody.angularVelocity.z;

            oldVelocity.copy(newVelocity);
        }

        setInterval(updateStats, 500);


        function useSensors()
        {
            var sensorDistance = 8;
            var sensorWidth = 20; // The width of the sensor in degrees.
            var sensorPrecision = 10;
            var results = [];

            for(i=-sensorPrecision; i<=sensorPrecision;i++)
            {
                TracyX = vehicles[0].chassisBody.position.x;
                TracyY = vehicles[0].chassisBody.position.y;
                TracyZ = vehicles[0].chassisBody.position.z;
                source = new CANNON.Vec3(TracyX, TracyY, TracyZ);

                // Front Sensor
                localTarget = new CANNON.Vec3(sensorDistance, (i/sensorPrecision) * Math.tan(sensorWidth/2.0) * sensorDistance, 0); 
                worldTarget = new CANNON.Vec3(0,0,0);
                vehicles[0].chassisBody.pointToWorldFrame(localTarget,worldTarget);
                leftSensorResult = new CANNON.RaycastResult();
                world.rayTest(source,worldTarget,leftSensorResult);

                if(leftSensorResult.hasHit)
                {
                    results.push("F");
                }

                // Right Sensor
                localTarget = new CANNON.Vec3((i/sensorPrecision) * Math.tan(sensorWidth/2.0) * sensorDistance, -sensorDistance, 0);
                worldTarget = new CANNON.Vec3(0,0,0);
                vehicles[0].chassisBody.pointToWorldFrame(localTarget,worldTarget);
                rightSensorResult = new CANNON.RaycastResult();
                world.rayTest(source,worldTarget,rightSensorResult);

                if(rightSensorResult.hasHit)
                {
                    results.push("R");
                }

                // Left Sensor
                localTarget = new CANNON.Vec3((i/sensorPrecision) * Math.tan(sensorWidth/2.0) * sensorDistance, sensorDistance, 0);
                worldTarget = new CANNON.Vec3(0,0,0);
                vehicles[0].chassisBody.pointToWorldFrame(localTarget,worldTarget);
                frontSensorResult = new CANNON.RaycastResult();
                world.rayTest(source,worldTarget,frontSensorResult);

                if(frontSensorResult.hasHit)
                {
                    results.push("L");
                }
            }

            alert(results);

            // DRAW VISUAL SHAPE TO SHOW SENSOR
            // var shape = new CANNON.Box(new CANNON.Vec3(1,1,1));
            // var body = new CANNON.Body({ mass: 1 });
            // body.addShape(shape);
            // body.quaternion.copy(vehicles[0].chassisBody.quaternion);
            // body.position.set( worldTarget.x,worldTarget.y,worldTarget.z );
            // demo.addVisual(body);
        }

        function testHit()
        {
            TracyX = vehicles[0].chassisBody.position.x;
            TracyY = vehicles[0].chassisBody.position.y;
            TracyZ = vehicles[0].chassisBody.position.z;

            from  = new CANNON.Vec3(TracyX, TracyY, TracyZ);
            tracyLeft = new CANNON.Vec3(10,0,0);
            tracyRight = new CANNON.Vec3(-10,0,0);
            tracyFront = new CANNON.Vec(0,10,0);

            worldLeft = new CANNON.Vec3(0,0,0);
            worldLeft = new CANNON.Vec3(0,0,0);
            worldLeft = new CANNON.Vec3(0,0,0);


            targetLeft = vehicles[0].chassisBody.pointToWorldFrame(localPosition,worldPosition);
            targetLeft = vehicles[0].chassisBody.pointToWorldFrame(localPosition,worldPosition);
            targetLeft = vehicles[0].chassisBody.pointToWorldFrame(localPosition,worldPosition);

            leftResult = new CANNON.RaycastResult();
            world.rayTest(from,to,result);
            //alert("FrontSensor:"result.hasHit+"LeftSensor:"result.hasHit+"RightSensor:"result.hasHit+);
                
            var shape = new CANNON.Box(new CANNON.Vec3(1,1,1));
            var body = new CANNON.Body({ mass: 1 });
            body.addShape(shape);
            body.quaternion.copy(vehicles[0].chassisBody.quaternion);
            body.position.set( worldPosition.x,worldPosition.y,worldPosition.z );
            demo.addVisual(body);

        }
        </script>
    </body>
</html>