<html>
 <meta charset="UTF-8"> 
    <head>
        <title>Tracy Demo</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100% }
        </style>
    </head>
    <body>
        <script src="js/three.min.js"></script>
        <script src="js/cannon.min.js"></script>
        <script src="build/cannon.js"></script>
        <script src="build/cannon.demo.js"></script>
        <script src="libs/dat.gui.js"></script>
        <script src="libs/Three.js"></script>
        <script src="libs/TrackballControls.js"></script>
        <script src="libs/Detector.js"></script>
        <script src="libs/Stats.js"></script>
        <script src="libs/Tracy.js"></script>
        <script src="libs/smoothie.js"></script>
        <script>
        var demo = new CANNON.Demo();
        var world = demo.getWorld();
        var vehicles = [];

        demo.addScene("car",function(){
            // Initialise world settings.
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.gravity.set(0, 0, -10);
            world.defaultContactMaterial.friction = 0.1;

            // Create materials.
            var groundMaterial = new CANNON.Material("groundMaterial");
            var wheelMaterial = new CANNON.Material("wheelMaterial");

            // Define ground to wheel material contact constraints.
            var wheelGroundContactMaterial = window.wheelGroundContactMaterial = new CANNON.ContactMaterial(wheelMaterial, groundMaterial, {
                friction: 0.3,
                restitution: 0,
                contactEquationStiffness: 1000
            });

            // Define ground to ground material contact constraints.
            var ground_ground_cm = new CANNON.ContactMaterial(groundMaterial, groundMaterial, {
                friction: 0.4,
                restitution: 0.3,
                contactEquationStiffness: 1e8,
                contactEquationRelaxation: 3,
                frictionEquationStiffness: 1e8,
                frictionEquationRegularizationTime: 3,
            });

            // We must add the contact materials to the world
            world.addContactMaterial(ground_ground_cm);
            world.addContactMaterial(wheelGroundContactMaterial);

            // Create four tracies and set their x,y,z positions.
            Simulator(-60,1,2);


            // Update wheels
            world.addEventListener('postStep', function(){
                for (var j = 0; j < vehicles.length; j++ ) {
                    for (var i = 0; i < vehicles[j].wheelInfos.length; i++) {
                        vehicles[j].updateWheelTransform(i);
                        var t = vehicles[j].wheelInfos[i].worldTransform;
                        var wheelBody = vehicles[j].wheelBodies[i];
                        wheelBody.position.copy(t.position);
                        wheelBody.quaternion.copy(t.quaternion);
                    }
                }
            });

            createFloor()

            // Create a ramp represented as a polyhedron.
            var polyhedronShape = createTetra();
            var polyhedronBody = new CANNON.Body({ mass: 1000, material: groundMaterial });
            polyhedronBody.addShape(polyhedronShape);
            polyhedronBody.position.set(20,-5,1);
            polyhedronBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0,0,1),THREE.Math.degToRad(135));
            world.addBody(polyhedronBody);
            demo.addVisual(polyhedronBody);


            var polyhedronShape = new CANNON.Box(new CANNON.Vec3(5,5,5));
            var polyhedronBody = new CANNON.Body({ mass: 1000, material: groundMaterial });
            polyhedronBody.addShape(polyhedronShape);
            polyhedronBody.position.set(-60,-10,10);
            polyhedronBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0,0,1),THREE.Math.degToRad(135));
            world.addBody(polyhedronBody);
            demo.addVisual(polyhedronBody);

        });

        demo.start();
        var maxSteerVal = 0.5;
        var maxForce = 500;
        var brakeForce = 1000000;
        var rotationForce = 8*maxForce;

        /**
         * Renders the ground as a height field.
         */
        function createFloor()
        {
            // Create a 64 x 16 matrix to store our height field.
            var matrix = [];
            var sizeX = 64,
                sizeY = 16;

            for (var i = 0; i < sizeX; i++) {
                matrix.push([]);
                for (var j = 0; j < sizeY; j++) {
                    height = 1;
                    matrix[i].push(height);
                }
            }

            var hfShape = new CANNON.Heightfield(matrix, {
                elementSize: 200 / sizeX
            });
            // Set mass to 0 so it is a static body and unaffected by gravity.
            var hfBody = new CANNON.Body({ mass: 0 });
            hfBody.addShape(hfShape);
            hfBody.position.set(-sizeX * hfShape.elementSize / 2, -sizeY * hfShape.elementSize / 2, -1);
            world.addBody(hfBody);
            demo.addVisual(hfBody);
        }


        function createTetra()
        {
            var verts = [new CANNON.Vec3(0,0,0),
                         new CANNON.Vec3(40,0,0),
                         new CANNON.Vec3(0,40,0),
                         new CANNON.Vec3(0,0,10)];
            var offset = -0.35;

            for(var i=0; i<verts.length; i++)
            {
                var v = verts[i];
                v.x += offset;
                v.y += offset;
                v.z += offset;
            }
            return new CANNON.ConvexPolyhedron(verts,[[0,3,2],[0,1,3],[0,2,1],[1,2,3]]);
        }

        // Keyboard Controls
        document.onkeydown = handler;
        document.onkeyup = handler;

        // Extra boost multiplier to make the car move slower or faster.
        var boost = 0.5;

        var test = {
            VelocityX: 0,
            VelocityY: 0,
            VelocityZ: 0,
            OriX:0,
            OriY:0,
            OriZ:0
        }

        wtf = new dat.GUI();
        wtf.addFolder("Accelerometer");
        wtf.add(test,"VelocityX",-20,20).listen();
        wtf.add(test,"VelocityY",-20,20).listen();
        wtf.add(test,"VelocityZ",-20,20).listen();

        wtf.addFolder("Orientation");
        wtf.add(test,"OriX",-1,1).listen();
        wtf.add(test,"OriY",-1,1).listen();
        wtf.add(test,"OriZ",-1,1).listen();
        wtf.close("Orientation");

        function showSpeed()
        {
            test.VelocityX = vehicles[0].chassisBody.velocity.x;
            test.VelocityY = vehicles[0].chassisBody.velocity.y;
            test.VelocityZ = vehicles[0].chassisBody.velocity.z;

            test.OriX = vehicles[0].chassisBody.quaternion.x;
            test.OriY = vehicles[0].chassisBody.quaternion.y;
            test.OriZ = vehicles[0].chassisBody.quaternion.z;
        }


        function useSensors()
        {
            var sensorDistance = 8;
            var sensorWidth = 20; // The width of the sensor in degrees.
            var sensorPrecision = 10;
            var results = [];

            for(i=-sensorPrecision; i<=sensorPrecision;i++)
            {
                TracyX = vehicles[0].chassisBody.position.x;
                TracyY = vehicles[0].chassisBody.position.y;
                TracyZ = vehicles[0].chassisBody.position.z;
                source = new CANNON.Vec3(TracyX, TracyY, TracyZ);

                // Front Sensor
                localTarget = new CANNON.Vec3(sensorDistance, (i/sensorPrecision) * Math.tan(sensorWidth/2.0) * sensorDistance, 0); 
                worldTarget = new CANNON.Vec3(0,0,0);
                vehicles[0].chassisBody.pointToWorldFrame(localTarget,worldTarget);
                leftSensorResult = new CANNON.RaycastResult();
                world.rayTest(source,worldTarget,leftSensorResult);
                var shape = new CANNON.Box(new CANNON.Vec3(1,1,1));
                var body = new CANNON.Body({ mass: 1 });
                body.addShape(shape);
                body.quaternion.copy(vehicles[0].chassisBody.quaternion);
                body.position.set( worldTarget.x,worldTarget.y,worldTarget.z );
                demo.addVisual(body);

                if(leftSensorResult.hasHit)
                {
                    results.push("F");
                }

                // Right Sensor
                localTarget = new CANNON.Vec3((i/sensorPrecision) * Math.tan(sensorWidth/2.0) * sensorDistance, -sensorDistance, 0);
                worldTarget = new CANNON.Vec3(0,0,0);
                vehicles[0].chassisBody.pointToWorldFrame(localTarget,worldTarget);
                rightSensorResult = new CANNON.RaycastResult();
                world.rayTest(source,worldTarget,rightSensorResult);

                if(rightSensorResult.hasHit)
                {
                    results.push("R");
                }

                // Left Sensor
                localTarget = new CANNON.Vec3((i/sensorPrecision) * Math.tan(sensorWidth/2.0) * sensorDistance, sensorDistance, 0);
                worldTarget = new CANNON.Vec3(0,0,0);
                vehicles[0].chassisBody.pointToWorldFrame(localTarget,worldTarget);
                frontSensorResult = new CANNON.RaycastResult();
                world.rayTest(source,worldTarget,frontSensorResult);

                if(frontSensorResult.hasHit)
                {
                    results.push("L");
                }
            }

            alert(results);
        }

        function testHit()
        {
            TracyX = vehicles[0].chassisBody.position.x;
            TracyY = vehicles[0].chassisBody.position.y;
            TracyZ = vehicles[0].chassisBody.position.z;

            from  = new CANNON.Vec3(TracyX, TracyY, TracyZ);
            tracyLeft = new CANNON.Vec3(10,0,0);
            tracyRight = new CANNON.Vec3(-10,0,0);
            tracyFront = new CANNON.Vec(0,10,0);

            worldLeft = new CANNON.Vec3(0,0,0);
            worldLeft = new CANNON.Vec3(0,0,0);
            worldLeft = new CANNON.Vec3(0,0,0);


            targetLeft = vehicles[0].chassisBody.pointToWorldFrame(localPosition,worldPosition);
            targetLeft = vehicles[0].chassisBody.pointToWorldFrame(localPosition,worldPosition);
            targetLeft = vehicles[0].chassisBody.pointToWorldFrame(localPosition,worldPosition);

            leftResult = new CANNON.RaycastResult();
            world.rayTest(from,to,result);
            //alert("FrontSensor:"result.hasHit+"LeftSensor:"result.hasHit+"RightSensor:"result.hasHit+);
                
            var shape = new CANNON.Box(new CANNON.Vec3(1,1,1));
            var body = new CANNON.Body({ mass: 1 });
            body.addShape(shape);
            body.quaternion.copy(vehicles[0].chassisBody.quaternion);
            body.position.set( worldPosition.x,worldPosition.y,worldPosition.z );
            demo.addVisual(body);

        }

        setInterval(showSpeed, 200);
        </script>
    </body>
</html>